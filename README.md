# 테스트와 객체지향 연습 프로젝트

## 테스트

### 테스트 코드 작성 이유

#### 1. 문서화

@DisplayName()에 설명만 잘 적어도 하나의 정리된 문서처럼 테스트 코드를 사용할 수 있음

#### 2. 코드에 결함을 발견하기 쉬움

테스트에 통과하지 못하면 바로 알아차릴 수 있어 결함을 발견하기 쉬움

#### 3. 리팩토링 시 안정성 확보

한줄의 리팩토링을 하더라도 바로바로 테스트를 돌릴 수 있어서 안정감이 높음

#### 4. 테스트하기 쉬운 코드를 작성하다 보면 더 낮은 결합도를 가진 설계를 할 수 있음

강결합된 코드들은 테스트하기가 어려운 경우가 많기에 테스트가 가능하게 코드를 리팩토링하면 결합도를 낮출 수 있음


## 객체 지향

TDD 기반의 코드로 연습을 진행함

### 객체 지향적 설계 및 구현

1. 도메인을 구성하는 객체에는 어떤 것들이 있는지 고민
2. 객체들 간의 관계를 고민
3. 동적인 객체를 정적인 타입으로 추상화해서 도메인 모델링 하기
4. 협력을 설계
5. 객체들을 포괄하는 타입에 적절한 책임을 할당
6. 구현하기

- 참고 : 객체지향 세계에서는 모든 객체가 능동적인 존재

# 배운점

## TDD 기반 개발

1. 테스트 코드를 작성한다.
2. 일단 테스트가 통과하도록 코드를 작성한다.(return 값을 그냥 4.5, 3 이런 식으로 상수로 줘서 통과하게끔 만든다.)
3. 리팩토링을 통해서 메소드를 수정하고 테스트를 돌려봄으로써 안정성을 얻을 수 있다.
4. 객체지향적인 점을 고려하여 리팩토링을 진행한다. (테스트 코드가 있으므로 수정하는 상황에서 코드가 망가질 위험이 굉장히 낮아진다.)

## 객체지향적 개발

### getter()를 통해서 정보를 받아와서 연산을 하는 것은 좋지 않다. (응집도)

예를 들어보자
```java

mulitipledCreditAndCourseGrade += course.getCredit() + course.getGradleNumber();
```

- course에서 두개의 정보를 getter()로 받아와서 계산하는 방식은 단점이 있다. 

만약 mulitpleCreditAndCourseGrade를 여러 곳에서 사용한다면 사용하는 곳마다 위의 로직을 작성하여야 한다.
따라서 mulitpleCreditAndCourseGrade를 가져오는 로직을 변경한다면 모든 곳의 로직을 변경해줘야한다.

```java
mulitipledCreditAndCourseGrade += course.multiplyCreditAndCourseGrade();
```

- getter()로 받아오는 것이 아닌 정보를 가진 객체에게 메세지를 보내 해당 객체에서 작업을 수행한 후 정보를 받는 방식으로 변경하는 경우는 단점을 보완할 수 있다.

만약 mulitpleCreditAndCourseGrade를 얻는 로직을 변경하더라도 course의 multiplyCreditAndCourseGrade() 메서드 하나의 로직만을 변경하면 된다.